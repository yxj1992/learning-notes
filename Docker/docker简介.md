### Docker简介  
关于 Docker 是什么，有个著名的隐喻：集装箱。但是它却起了个“码头工人”（docker 的英文翻译）的名字。  

在集装箱之前，货物运输没有统一的标准方式进行搬运，于是铁路、公路、海洋等各种运输之间，需要大量的人力作为货物中转，效率极低，而且成本很高。集装箱出现之后，世界上绝大多数的货物运输都可以放到这个神奇的箱子里，然后在公路、铁路、海洋等所有运输场景下，这个箱子都可以不用变化形态直接可以承运，而且中间的中转工作，都可以通过大型机械搞定，效率大大提升。从此全球化开始，商业的潜力被进一步挖掘......牛逼之处我就不多说了，可是这个箱子为什么这么神奇呢？答案其实也就在上面的描述中，无非就是两个字：**标准**。  

这就是 docker 的实质：穿着马甲的标准化。docker 的发明人根据自己运维 PAAS 平台的经验，重新思考了自己的工作，将 PAAS 平台的 devops 工作从各个角度标准化了一下，将系统底层实现的 cgroup、namespace、aufs｜device mapper 等技术集成在一个使用镜像方式发布的工具中，于是形成了 docker。观察 docker 形成的思考过程，其实就是作者针对他所运维的场景如何做自动化运维的思考。  

那么 Docker 的实质是什么？在我看来就是个针对 PAAS 平台的自动化运维工具而已。众所周知（当然如果你不知道，那么我来告诉你）：自动化运维的大前提就是标准化。  

标准化了，才能基于标准建设属于你们系统的自动化运维。那么我们再来看看 docker 是怎么做的？  

- 首先，标准化就要有标准化的文档规范，要定义系统软件版本等一系列内容。规范好了之后，大家开始实施。但是在长期运维的过程中，很可能出现随着系统的发展，文档内容已经过时了，工程师又来不及更新文档的问题。怎么解决？docker 给出的答案是：用 dockerfile。dockerfile 就是你的文档，并且用来产生镜像。要改变 docker 镜像中的环境，先改 dockerfile，用它产生镜像就行了，保证文档和环境一致。那么现实是，有多少在使用 docker 的人是这样用的？你们是不是嫌这样麻烦，于是干脆直接在线 docker commit 产生镜像，让文档跟现场环境又不符了？或者我还是太理想，因为你们压根连文档都没有？  

- 其次，标准化要有对应用统一操作的方法。在现实中，即使你用的是 php 开发的应用，启动的方式都可能不尽相同。有用 apache 的，有用 nginx 的，还有用某种不知名 web 容器的，甚至是自己开发 web 容器的。如果操作范围扩大到包含 java 等其它语言，或数据库等其它服务，那么操作方式更是千奇百怪。虽然 UNIX 操作系统早就对此作了统一的规范，就是大家常见的把启动脚本放到/etc/rc.d 中，SYSV 标准中甚至规定了启动脚本该怎么写，应该有哪些方法。但是绝大多数人不知道，或者知道了也不这么做，他们习惯用./start 作为自己业务启动的唯一标准。甚至./是哪个目录可能都记不住。于是 docker 又给出了解决方案：我压根不管你怎么启动，你自己爱咋来咋来，我们用 docker start 或 run 作为统一标准。于是 docker start 可以启动一个 apache、nginx、jvm、mysql 等等。有人病垢 docker 的设计，质疑它为什么设计上一个容器内只给启动一个进程？这就是原因：人家压根不是为了给你当虚拟机用的，人家是为了给启动生产环境的进程做标准化的！  

- 第三，为了维护生产环境的一致性和配置变更的幂等，docker 创造性的使用了类似 git 管理代码的方式对环境镜像进行管理。于是：  
你想做库版本升级吗？更新个镜像吧！  
你想做 php、java 的版本升级吗？更新个镜像吧。  
好方便！太爽了！  
等等......神马？你想改变 apache 配置文件中的一个字段？做个新镜像升级吧！  
你的 php 代码写错了一行要改个 bug？做个新镜像升级吧......  